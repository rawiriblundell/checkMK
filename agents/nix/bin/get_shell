# shellcheck shell=sh
# vim: noai:ts=4:sw=4:expandtab

# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# Because $SHELL is an unreliable thing to test against (e.g. SHLVL > 1), we provide this tool
# It tries multiple methods to discover and name the invoking shell
# This won't work for 'fish', which needs 'ps -p %self' or similar non-bourne-esque syntax.
get_shell() {
    if [ -r "/proc/$$/cmdline" ]; then
        # We use 'tr' because 'cmdline' files have NUL terminated lines
        # TO-DO: Possibly handle multi-word output e.g. 'busybox ash'
        printf -- '%s\n' "$(tr '\0' ' ' </proc/"$$"/cmdline)"
    elif ps -p "$$" >/dev/null 2>&1; then
        # This double-awk caters for situations where CMD/COMMAND
        # might be a full path e.g. /usr/bin/zsh
        ps -p "$$" | tail -n 1 | awk '{print $NF}' | awk -F '/' '{print $NF}' | tr -d '()'
    # This one works well except for busybox
    elif ps -o comm= -p "$$" >/dev/null 2>&1; then
        ps -o comm= -p "$$"
    elif ps -o pid,comm= >/dev/null 2>&1; then
        ps -o pid,comm= | awk -v ppid="$$" '$1==ppid {print $2}'
    else
        case "${BASH_VERSION}" in (*.*) printf -- '%s\n' "bash";; esac; return 0
        case "${KSH_VERSION}" in (*.*) printf -- '%s\n' "ksh";; esac; return 0
        case "${ZSH_VERSION}" in (*.*) printf -- '%s\n' "zsh";; esac; return 0
        # If we get to this point, fail out:
        return 1
    fi
}

get_shell